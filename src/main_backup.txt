#include <Arduino.h>
#include <FlexCAN_T4.h>

#define CCSN_IN 25
#define CCSP_IN 24
#define MCONN_IN 20
#define MCONP_IN 21
#define BMS_OK_IN 16
#define REGEN_IN 17

#define MCONP_GATE 19
#define MCONN_GATE 18
#define CCSP_GATE 13
#define CCSN_GATE 14
#define PRECHARGE 12

enum ContactorState { OFF, STARTUP, ECONOMIZED };
ContactorState ccsnState = OFF, ccspState = OFF, mconpState = OFF, mconnState = OFF;

enum SystemState { IDLE, PRECHARGING, CONTACTORS_ON, PRECHARGE_FAILED_TIMEOUT, PRECHARGE_BLOCKED };
SystemState systemState = IDLE;

const uint16_t PWM_FREQ = 20000;
const uint8_t ECONOMY_DUTY_CYCLE = 30;
const uint16_t FULL_CURRENT_TIME = 500;

// CAN settings
#define CAN_ID_INPUT 0x108    // VCU HV enable request (CUSTOM-VEHICLE-CAN)
#define CAN_ID_STATUS 0x398   // Status output (CUSTOM-VEHICLE-CAN)
#define CAN_ID_GFM 0x293      // GFM v2 CANOpen ID (CUSTOM-VEHICLE-CAN)
#define CAN_ID_BMS 0x132      // BMS voltage/current (ID132HVBattAmpVolt, TESLA-PRTY-CAN)
#define CAN_ID_MOTOR 0x126    // Motor HV voltage (ID126RearHVStatus, TESLA-VEHICLE-CAN)
#define CAN_ID_MAX_POWER 0x696  // T2C power limit (TESLA-VEHICLE-CAN)
#define CAN_ID_SHIFT 0x697    // T2C shift command (TESLA-VEHICLE-CAN)

FlexCAN_T4<CAN1, RX_SIZE_256, TX_SIZE_16> Can1;  // TESLA-VEHICLE-CAN: T2C and drive unit
FlexCAN_T4<CAN2, RX_SIZE_256, TX_SIZE_16> Can2;  // CUSTOM-VEHICLE-CAN: GFM, VCU, etc.
FlexCAN_T4<CAN3, RX_SIZE_256, TX_SIZE_16> Can3;  // TESLA-PRTY-CAN: T2C, BMS, drive unit stats
CAN_message_t rxMsg, txMsg;

unsigned long lastCanSendTime = 0;
const unsigned long CAN_SEND_INTERVAL = 100;
unsigned long ccsnStartTime = 0, ccspStartTime = 0;
unsigned long mconpStartTime = 0, mconnStartTime = 0;
unsigned long prechargeStartTime = 0;
const unsigned long PRECHARGE_TIMEOUT = 5000;

float batteryVoltage = 0.0;
float rearMotorVoltage = 0.0;
uint8_t rearMotorVoltageQF = 0;
const float PRECHARGE_VOLTAGE_THRESHOLD = 0.95;
uint16_t gfmIsolation = 0;
const uint16_t GFM_ISO_THRESHOLD = 500;

bool hvOnRequested = false;
bool canHvRequest = false;
bool hwHvRequest = false;

void handleCCScontactor(uint8_t inputPin, uint8_t outputPin, ContactorState &state, unsigned long &startTime);
void handleMainContactor(ContactorState &state, bool enable, uint8_t outputPin, unsigned long &startTime);
void economizeGate(uint8_t outputPin, ContactorState &state);
void sendStateViaCAN();
void gatewayMessages();
void processBmsAndMotorMessages();
void checkHvRequest();
bool isIsolationOk();
void processHVStateMachine();

void setup() {
  pinMode(CCSN_IN, INPUT_PULLDOWN);
  pinMode(CCSP_IN, INPUT_PULLDOWN);
  pinMode(MCONP_IN, INPUT_PULLDOWN);
  pinMode(MCONN_IN, INPUT_PULLDOWN);
  pinMode(BMS_OK_IN, INPUT_PULLDOWN);
  pinMode(REGEN_IN, INPUT_PULLDOWN);

  pinMode(MCONP_GATE, OUTPUT);
  pinMode(MCONN_GATE, OUTPUT);
  pinMode(CCSP_GATE, OUTPUT);
  pinMode(CCSN_GATE, OUTPUT);
  pinMode(PRECHARGE, OUTPUT);
  pinMode(LED_BUILTIN, OUTPUT);

  digitalWrite(MCONP_GATE, LOW);
  digitalWrite(MCONN_GATE, LOW);
  digitalWrite(CCSP_GATE, LOW);
  digitalWrite(CCSN_GATE, LOW);
  digitalWrite(PRECHARGE, LOW);

  analogWriteFrequency(MCONP_GATE, PWM_FREQ);
  analogWriteFrequency(MCONN_GATE, PWM_FREQ);
  analogWriteFrequency(CCSP_GATE, PWM_FREQ);
  analogWriteFrequency(CCSN_GATE, PWM_FREQ);
  analogWriteResolution(8);

  Can1.begin(); Can1.setBaudRate(500000);
  Can1.setMBFilter(MB0, CAN_ID_MAX_POWER);
  Can1.setMBFilter(MB1, CAN_ID_SHIFT);
  Can1.setMBFilter(MB2, CAN_ID_MOTOR);

  Can2.begin(); Can2.setBaudRate(500000);
  Can2.setMBFilter(MB0, CAN_ID_GFM);
  Can2.setMBFilter(MB1, CAN_ID_INPUT);
  Can2.setMBFilter(MB2, CAN_ID_MAX_POWER);
  Can2.setMBFilter(MB3, CAN_ID_SHIFT);

  Can3.begin(); Can3.setBaudRate(500000);
  Can3.setMBFilter(MB0, CAN_ID_BMS);

  txMsg.id = CAN_ID_STATUS;
  txMsg.len = 7;
  txMsg.flags.extended = 0;
}

void loop() {
  processBmsAndMotorMessages();
  gatewayMessages();

  checkHvRequest();
  processHVStateMachine();

  handleCCScontactor(CCSN_IN, CCSN_GATE, ccsnState, ccsnStartTime);
  handleCCScontactor(CCSP_IN, CCSP_GATE, ccspState, ccspStartTime);

  if (millis() - lastCanSendTime >= CAN_SEND_INTERVAL) {
    lastCanSendTime = millis();
    sendStateViaCAN();
    digitalToggle(LED_BUILTIN);
  }
}

void checkHvRequest() {
  canHvRequest = false;
  hwHvRequest = false;

  if (Can2.read(rxMsg) && rxMsg.id == CAN_ID_INPUT) {
    canHvRequest = (rxMsg.buf[0] == 0xAA);
  }
  hwHvRequest = digitalRead(MCONP_IN);

  hvOnRequested = canHvRequest || hwHvRequest;
}

void processHVStateMachine() {
  switch (systemState) {
    case IDLE:
      if (hvOnRequested && isIsolationOk() && digitalRead(BMS_OK_IN)) {
        systemState = PRECHARGING;
        digitalWrite(PRECHARGE, HIGH);
        prechargeStartTime = millis();
      } else if (hvOnRequested && !isIsolationOk()) {
        systemState = PRECHARGE_BLOCKED;
        digitalWrite(PRECHARGE, LOW);
        handleMainContactor(mconpState, false, MCONP_GATE, mconpStartTime);
        handleMainContactor(mconnState, false, MCONN_GATE, mconnStartTime);
      } else {
        digitalWrite(PRECHARGE, LOW);
        handleMainContactor(mconpState, false, MCONP_GATE, mconpStartTime);
        handleMainContactor(mconnState, false, MCONN_GATE, mconnStartTime);
      }
      break;

    case PRECHARGING:
      if (!isIsolationOk()) {
        digitalWrite(PRECHARGE, LOW);
        systemState = PRECHARGE_BLOCKED;
      } else if (rearMotorVoltageQF == 1 && batteryVoltage > 0 && rearMotorVoltage >= batteryVoltage * PRECHARGE_VOLTAGE_THRESHOLD) {
        digitalWrite(PRECHARGE, LOW);
        systemState = CONTACTORS_ON;
      } else if (millis() - prechargeStartTime >= PRECHARGE_TIMEOUT) {
        digitalWrite(PRECHARGE, LOW);
        systemState = PRECHARGE_FAILED_TIMEOUT;
      }
      break;

    case CONTACTORS_ON:
      if (!isIsolationOk()) {
        handleMainContactor(mconpState, false, MCONP_GATE, mconpStartTime);
        handleMainContactor(mconnState, false, MCONN_GATE, mconnStartTime);
        systemState = IDLE;
      } else {
        handleMainContactor(mconpState, true, MCONP_GATE, mconpStartTime);
        handleMainContactor(mconnState, true, MCONN_GATE, mconnStartTime);
      }
      break;

    case PRECHARGE_FAILED_TIMEOUT:
      handleMainContactor(mconpState, false, MCONP_GATE, mconpStartTime);
      handleMainContactor(mconnState, false, MCONN_GATE, mconnStartTime);
      digitalWrite(PRECHARGE, LOW);
      if (!hvOnRequested) systemState = IDLE;
      break;

    case PRECHARGE_BLOCKED:
      handleMainContactor(mconpState, false, MCONP_GATE, mconpStartTime);
      handleMainContactor(mconnState, false, MCONN_GATE, mconnStartTime);
      digitalWrite(PRECHARGE, LOW);
      if (!hvOnRequested) systemState = IDLE;
      if (hvOnRequested && isIsolationOk()) {
        systemState = PRECHARGING;
        digitalWrite(PRECHARGE, HIGH);
        prechargeStartTime = millis();
      }
      break;
  }
}

void processBmsAndMotorMessages() {
  if (Can1.read(rxMsg)) {
    if (rxMsg.id == CAN_ID_MOTOR) {
      rearMotorVoltage = (rxMsg.buf[0] | (rxMsg.buf[1] & 0x03) << 8) * 0.5;
      rearMotorVoltageQF = (rxMsg.buf[1] >> 2) & 0x01;
      Can2.write(rxMsg);
    }
  }
  if (Can3.read(rxMsg)) {
    if (rxMsg.id == CAN_ID_BMS) {
      batteryVoltage = ((rxMsg.buf[0] << 8) | rxMsg.buf[1]) * 0.01;
      Can2.write(rxMsg);
    }
  }
  if (Can2.read(rxMsg)) {
    if (rxMsg.id == CAN_ID_GFM) {
      gfmIsolation = (rxMsg.buf[2] << 8) | rxMsg.buf[3];
    }
  }
}

bool isIsolationOk() {
  return gfmIsolation >= GFM_ISO_THRESHOLD;
}

void handleCCScontactor(uint8_t inputPin, uint8_t outputPin, ContactorState &state, unsigned long &startTime) {
  if (digitalRead(inputPin)) {
    if (state == OFF) {
      state = STARTUP;
      analogWrite(outputPin, 255);
      startTime = millis();
    }
    if (state == STARTUP && millis() - startTime >= FULL_CURRENT_TIME) {
      economizeGate(outputPin, state);
    }
  } else {
    if (state != OFF) {
      analogWrite(outputPin, 0);
      state = OFF;
    }
  }
}

void handleMainContactor(ContactorState &state, bool enable, uint8_t outputPin, unsigned long &startTime) {
  if (enable) {
    if (state == OFF) {
      state = STARTUP;
      analogWrite(outputPin, 255);
      startTime = millis();
    }
    if (state == STARTUP && millis() - startTime >= FULL_CURRENT_TIME) {
      economizeGate(outputPin, state);
    }
  } else {
    if (state != OFF) {
      analogWrite(outputPin, 0);
      state = OFF;
    }
  }
}

void economizeGate(uint8_t outputPin, ContactorState &state) {
  state = ECONOMIZED;
  analogWrite(outputPin, ECONOMY_DUTY_CYCLE * 255 / 100);
}

void sendStateViaCAN() {
  uint8_t hvReqSource = 0;
  if (canHvRequest) hvReqSource |= 0x01;
  if (hwHvRequest) hvReqSource |= 0x02;

  txMsg.buf[0] = mconpState;
  txMsg.buf[1] = mconnState;
  txMsg.buf[2] = ccspState;
  txMsg.buf[3] = ccsnState;
  txMsg.buf[4] = digitalRead(REGEN_IN);
  txMsg.buf[5] = systemState;
  txMsg.buf[6] = hvReqSource;
  txMsg.len = 7;
  Can2.write(txMsg);
}

void gatewayMessages() {
  if (Can2.read(rxMsg)) {
    if (rxMsg.id == CAN_ID_MAX_POWER || rxMsg.id == CAN_ID_SHIFT) {
      Can1.write(rxMsg);
    }
  }
}
